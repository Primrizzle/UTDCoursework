// Implementation of RedBlack tree. The RedBlack Tree is a self-balancing binary search tree 
// Code included but missing logic

//
//  main.cpp
//  RedBlackTree
//
//  Created by Ashley Primrose on 12/7/22.
//

#include <iostream>

int main(int argc, const char * argv[]) {
    class RBTree
    {
    public:
        RBTree() : root(NULL) {}
        
        void insert(int data);
        void inorder();
        void convertTo24();
        void convertToRB();
        
        
    private:
        struct Node
        {
            int data;
            bool color;
            Node *left, *right, *parent;
            
            Node(int data)
            {
                this->data = data;
                left = right = parent = NULL;
                
                this->color = 1;
            }
        };
        
        Node *root;
        
        void rotateLeft(Node *&, Node *&);
        void rotateRight(Node *&, Node *&);
        void fixViolation(Node *&, Node *&);
    };
}
    void inorderHelper(Node *root) {
        if (root == NULL)
            return;
     
        inorderHelper(root->left);
        std::cout << root->data << "  ";
        inorderHelper(root->right);
    }
     
    void RBTree::inorder()
    {
        inorderHelper(root);
    }
    void RBTree::rotateLeft(Node *&root, Node *&pt)
    {
        Node *pt_right = pt->right;
     
        pt->right = pt_right->left;
     
        if (pt->right != NULL)
            pt->right->parent = pt;
     
        pt_right->parent = pt->parent;
     
        if (pt->parent == NULL)
            root = pt_right;
     
        else if (pt == pt->parent->left)
            pt->parent->left = pt_right;
     
        else
            pt->parent->right = pt_right;
     
        pt_right->left = pt;
        pt->parent = pt_right;
    }
     
    void RBTree::rotateRight(Node *&root, Node *&pt)
    {
        Node *pt_left = pt->left;
     
        pt->left = pt_left->right;
     
        if (pt->left != NULL)
            pt->left->parent = pt;
     
        pt_left->parent = pt->parent;
     
        if (pt->parent == NULL)
            root = pt_left;
     
        else if (pt == pt->parent->left)
            pt->parent->left = pt_left;
     
        else
            pt->parent->right = pt_left;
     
        pt_left->right = pt;
        pt->parent = pt_left;
    }
     
    void RBTree::fixViolation(Node *&root, Node *&pt)
    {
        Node *parent_pt = NULL;
        Node *grand_parent_pt = NULL;
     
        while ((pt != root) && (pt->color != 0) &&
               (pt->parent->color == 1))
        {
     
            parent_pt = pt->parent;
            grand_parent_pt = pt->parent->parent;
     
            if (parent_pt == grand_parent_pt->left)
            {
     
                Node *uncle_pt = grand_parent_pt->right;
     
                if (uncle_pt != NULL && uncle_pt->color == 1)
                {
                    grand_parent_pt->color = 1;
                    parent_pt->color = 0;
                    uncle_pt->color = 0;
                    pt = grand_parent_pt;
                }
     
                else
                {
                    if (pt == parent_pt->right)
                    {
                        rotateLeft(root, parent_pt);
                        pt = parent_pt;
                        parent_pt = pt->parent;
                    }
     
                    rotateRight(root, grand_parent_pt);
                    swap(parent_pt->color, grand_parent_pt->color);
                    pt = parent_pt;
                }
            }
     
            else
            {
                Node *uncle_pt = grand_parent_pt->left;
     
                if ((uncle_pt != NULL) && (uncle_pt->color == 1))
                {
                    grand_parent_pt->color = 1;
                    parent_pt->color = 0;
                    uncle_pt->color = 0;
                    pt = grand_parent_pt;
                }
                else
                {
                    if (pt == parent_pt->left)
                    {
                        rotateRight(root, parent_pt);
                        pt = parent_pt;
                        parent_pt = pt->parent;
                    }
     
                    rotateLeft(root, grand_parent_pt);
                    swap(parent_pt->color, grand_parent_pt->color);
                    pt = parent_pt;
                }
            }
        }
     
        root->color = 0;
    }
     
    void RBTree::insert(int data)
    {
        Node *pt = new Node(data);
     
        root = BSTInsert(root, pt);
     
        fixViolation(root, pt);
    }
     
    Node* RBTree::BSTInsert(Node* root, Node* pt)
    {
        if (root == NULL)
           return pt;
     
        if (pt->data < root->data)
        {
            root->left  = BSTInsert(root->left, pt);
            root->left->parent = root;
        }
        else if (pt->data > root->data)
        {
            root->right = BSTInsert(root->right, pt);
            root->right->parent = root;
        }
     
        return root;
    }
     
    void convertTo24Helper(Node *root)
    {
        if (root == NULL)
            return;
     
        convertTo24Helper(root->left);
        cout << root->data << "  ";
        convertTo24Helper(root->right);
    }
     
    void RBTree::convertTo24()
    {
        convertTo24Helper(root);
    }
     
    void convertToRBHelper(Node *root)
    {
        if (root == NULL)
            return;
     
        convertToRBHelper(root->left);
        cout << root->data << "  ";
        convertToRBHelper(root->right);
    }
     
    void RBTree::convertToRB()
    {
        convertToRBHelper(root);
    }


